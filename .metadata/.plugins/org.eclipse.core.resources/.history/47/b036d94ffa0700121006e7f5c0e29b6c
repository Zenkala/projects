--write data to pwm channel :

 --put write_en high to indicate write start
 --wait for write_allowed to go high to indicate data can be written, 
  
--  <repeat for each data bit>
--    if(write_allowed != low)
--      setup data
--      send clock pulse
--    else
--      -error
--      break;
--    end if;
--  </repeat>

  
--check for write_allowed to be low, otherwise not all data was received  
--set write_en low to indicate end of write

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity compare_unit is
  generic (compare_width : positive := 8);
	port (
		clk : in std_logic;
		data, data_clk : in std_logic;
		reset : in std_logic;
		write_en : in std_logic;
		cnt_value : in unsigned (compare_width downto 0);
		pwm_out : out std_logic
	);
end entity compare_unit;

architecture behaviour of compare_unit is
	
	signal compare_value : unsigned (compare_width downto 0) := (others => '0');
	signal compare_temp  : unsigned (compare_width downto 0) := (others => '0');
	signal new_value : boolean := false;
	
begin

  --output pwm signal only when write enable is not set. SYNCHRONIZE!
  pwm_out <= '1' when compare_value > cnt_value and new_value = '0' else '0';
  
 
  
  gather_data: process 
  
    variable write_busy : boolean := false;
    variable bits_written : integer range 0 to (compare_width+1) := 0; 
  
  begin
  
    wait until rising_edge(clk);
    
    if write_en = "1" and write_busy then
      
  
  
  
  
  
  
  end process gather_data;



end architecture behaviour;
