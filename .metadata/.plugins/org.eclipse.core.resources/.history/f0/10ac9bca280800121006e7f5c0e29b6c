--write data to pwm channel :

 --put write_en high to indicate write start
 --wait for write_allowed to go high to indicate data can be written, 
  
--  <repeat for each data bit>
--    if(write_allowed != low)
--      setup data
--      send clock pulse
--    else
--      -error
--      break;
--    end if;
--  </repeat>

  
--check for write_allowed to be low, otherwise not all data was received  
--set write_en low to indicate end of write

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity interface is
  generic (data_width : positive := 8);
	port (
		clk : in std_logic;
		data_in, data_clk : in std_logic;
		reset : in std_logic;
		write_en : in std_logic;
		data_out : out unsigned (data_width downto 0)	
	);
end entity interface;

architecture behaviour of interface is
	
	signal compare_value : unsigned (data_width downto 0) := (others => '0');
	signal compare_temp  : unsigned (data_width downto 0) := (others => '0');
	signal new_value : boolean := false;
	
begin

  --output pwm signal only when write enable is not set. SYNCHRONIZE!
  pwm_out <= '1' when compare_value > cnt_value and new_value = '0' else '0';
  
 
  
--  write_en not high:
--  -reset bits written
--  -disable write_busy
--  
--  write_en high, bit should be written
--  -enable write_busy bit
--  -listen on data clock to clock in data
--  -after data clocked in, increment bits written, should not exceed compare_width + 1
--
--  write_en high, no more bits should be written
--  -disable write_busy bit
--  -dont listen on data input
--  -keep bits_written value (if not compare_width + 1,  something went wrong and value should be set to 0)
  
  gather_data: process 
  
    variable write_busy : boolean := false;
    variable bits_written : integer range 0 to (data_width+1) := 0; 
  
  begin
  
    wait until rising_edge(data_clk);
    
    if write_en = '0' then
      bits_written := 0;
      write_busy := false;
    elsif write_en = '1' and bits_written < data_width + 1 then
      write_busy := true;
      compare_temp <= compare_temp((data_width-1) downto 0) & data; --shift in new data
      bits_written := bits_written + 1;
    else
      write_busy := false;
      if bits_written < data_width + 1
  
  
  
  
  
  
  end process gather_data;



end architecture behaviour;
